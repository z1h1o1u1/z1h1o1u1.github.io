<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo+github建站指南</title>
    <link href="/2023/02/10/hexo-github%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97/"/>
    <url>/2023/02/10/hexo-github%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在GitHubu上，是搭建博客的首选框架。</p><h2 id="step1：Node-js"><a href="#step1：Node-js" class="headerlink" title="step1：Node.js"></a>step1：Node.js</h2><p>Hexo基于Node.js，所以点击下载<a href="https://nodejs.org/en/download/">Download | Node.js (nodejs.org)</a>一路根据提示NEXT，然后在<strong>命令行</strong>中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><p>出现版本号意味着安装成功，然后在<strong>命令行</strong>换个镜像源，加个速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h2 id="step2：安装git"><a href="#step2：安装git" class="headerlink" title="step2：安装git"></a>step2：安装git</h2><p>什么是Git<br>Git是目前世界上最先进的分布式版本控制系统。<br>简单来说，Git就是一个可以帮你记录文件改动，共同编辑的一个软件<br><a href="https://git-scm.com/downloads">Git - 下载 (git-scm.com)</a><br>这里分享一个详细安装教程<br><a href="https://blog.csdn.net/mukes/article/details/115693833">( Git 详细安装教程</a></p><h2 id="step3：创建仓库"><a href="#step3：创建仓库" class="headerlink" title="step3：创建仓库"></a>step3：创建仓库</h2><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号 点击GitHub中的New repository创建新仓库，仓库名应该为：<strong>用户名</strong>.github.io这个<strong>用户名</strong>使用你的GitHub帐号名称代替，这是<strong>固定写法</strong>，比如我的仓库名为：z1h1o1u1.github.io</p><h2 id="step4：安装hexo"><a href="#step4：安装hexo" class="headerlink" title="step4：安装hexo"></a>step4：安装hexo</h2><p>在本地喜欢的地方新建一个文件夹，用来存放自己的博客文件，我的博客文件都存放在H:\zhou’s blog\blog。然后在根目录下右键点击<strong>git bash here</strong>进入git的控制台窗口<br>使用npm命令安装Hexo，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli <br></code></pre></td></tr></table></figure><p>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><p>接着输入安装必备的组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%A2%84%E8%A7%88%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E6%9C%80%E5%90%8ECTRL+c%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1">http://localhost:4000/，就可以预览我们的博客啦，最后CTRL+c关闭服务</a></p><h2 id="step5：连接GitHub"><a href="#step5：连接GitHub" class="headerlink" title="step5：连接GitHub"></a>step5：连接GitHub</h2><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;         &quot;</span><br>git config --global user.email <span class="hljs-string">&quot;       &quot;</span><br></code></pre></td></tr></table></figure><p>用户名和邮箱根据你注册github的信息输入<br>然后生成密钥SSH key：然后直接三个回车即可，默认不需要设置密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;              &quot;</span><br></code></pre></td></tr></table></figure><p>打开github在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code><br>将C:\Users\XXXXX.ssh文件夹中的id_rsa.pub密钥，将内容全部复制</p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 ssh <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a> ：<br>这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。当你推送的时候，这样可以保证每次的推送都是正确合法的。</p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。<br>修改最后一行的配置：冒号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: <br>  branch: main<br></code></pre></td></tr></table></figure><p>repository修改为你自己的github项目地址。<br><strong>注意</strong><br><strong>branch后面一定要根据自己的分支看看是main还是master</strong><br>以上其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，最后安装Git部署插件，在命令行里输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basemake">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>这时，我们在git的控制台窗口分别输入三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean <br>hexo g <br>hexo d<br></code></pre></td></tr></table></figure><h2 id="step6：更换主题"><a href="#step6：更换主题" class="headerlink" title="step6：更换主题"></a>step6：更换主题</h2><p>hexo还有一个好处就是有着许多主题，我才用的是fluid主题<a href="https://hexo.fluid-dev.com/docs/start/#%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a><br>手册写的非常详细十分友好</p><h2 id="step7：写文章"><a href="#step7：写文章" class="headerlink" title="step7：写文章"></a>step7：写文章</h2><p>写文章，插图一定是一个令人头疼的事<br>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>插件hexo-renderer-marked解决了这个问题。可以在命令行中用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a>  </p><p>然后在git的控制台窗口输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。<br>然后打开\source_posts目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>编写完markdown文件后，根目录下输入<code>hexo clean</code>，<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2023/02/07/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/07/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。<br>简单来说，Git就是一个可以帮你记录文件改动，共同编辑的一个软件</p><h2 id="集中式与分布式"><a href="#集中式与分布式" class="headerlink" title="集中式与分布式"></a>集中式与分布式</h2><p>CVS和SVN都是集中式的版本控制系统，对于集中式版本控制系统，库是集中存放在中央服务器的，干活的时候，用自己的电脑，首先要从中央服务器中得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<br><img src="/2023/02/07/Git%E7%AC%94%E8%AE%B0/1.jpg" alt="jizhong"><br>缺点：必须联网才能工作，如遇到网速慢的情况就~~~~~😂十分痛苦</p><p>Git是分布式版本控制系统，那么它没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了。</p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p><a href="https://git-scm.com/downloads">Git - 下载 (git-scm.com)</a><br>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，<strong>每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> 文件夹名称</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> 文件夹名称</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pwd</span></span><br><br></code></pre></td></tr></table></figure><p>创建后</p><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> <span class="hljs-regexp">/Users/mi</span>chael<span class="hljs-regexp">/learngit/</span>.git/<br></code></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>如果你没有看到<code>.git</code>目录，别着急，那是因为这个目录默认是隐藏的，</p><p>现在，我们创建一个<code>readme.txt</code>文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">hi <span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> git study<br></code></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。<br>把一个文件放到Git仓库只需要两步。</p><ul><li>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</li><li>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git add readme.txt<br><br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[master (root-commit) eaadf4e] wrote a readme <span class="hljs-keyword">file</span><br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">2</span> insertions(+)<br> create mode <span class="hljs-number">100644</span> readme.txt<br></code></pre></td></tr></table></figure>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录，知道自己做了什么改动。这和编程里的注释的作用有异曲同工之妙。</li></ul><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加readme.txt文件）；<code>1 insertions</code>：插入了两行内容（readme.txt有1行内容）。<br>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> file1.txt<br>$ git <span class="hljs-built_in">add</span> file2.txt file3.txt<br>$ git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="进一步工作"><a href="#进一步工作" class="headerlink" title="进一步工作"></a>进一步工作</h3><p>现在我们进一步工作，修改一下readme文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">hi</span> this <span class="hljs-keyword">is</span> git study<br><span class="hljs-keyword">hi</span> I <span class="hljs-keyword">am</span> charon<br></code></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改<br>用<code>git diff</code>这个命令，能看看具体修改了什么内容</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">$ git diff readme.txt <br><span class="hljs-comment">diff --git a/readme.txt b/readme.txt</span><br><span class="hljs-comment">index 46d49bf..9247db6 100644</span><br><span class="hljs-comment">--- a/readme.txt</span><br><span class="hljs-comment">+++ b/readme.txt</span><br><span class="hljs-meta">@@ -1,2 +1,2 @@</span><br>具体更改<br></code></pre></td></tr></table></figure><blockquote><p>常见问题-Git no newline at end of file<br>分析：原文链接：<a href="https://blog.csdn.net/gao_zhennan/article/details/120217246">https://blog.csdn.net/gao_zhennan/article/details/120217246</a><br>文件的末尾没有文件换行符，似乎没有什么问题。但是仔细思考，就会发现问题所在。文本文件内容的修改是基于刚定位的，也就是说对于某行添加或者删除了若干字符，git无法定位到这些字符的表动。针对此行来说，前后内容变化了，git理解为先删除修改前的此行后添加修改后的此行。于是，问题产生了。由于行的末尾没有换行符，如果我们想在新的一行上添加内容，首先要输入换行符。原来没有换行符，现在添加了换行符，那么这一行的内容就发生了改变，就会先删除原来没有换行符的“行”，添加有换行符的行。<br>解决：只要在文件末尾添加一个换行就好了（按一个回车就OK了，就要保证文件的最后一行是一个空行）或在末尾手动添加换行符</p></blockquote><p>交修改和提交新文件是一样的两步</p><ul><li>第一步是<code>git add</code></li><li>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ git status<br><span class="hljs-keyword">On</span> branch master<br>Changes <span class="hljs-keyword">to</span> be committed:<br>  (<span class="hljs-keyword">use</span> <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> unstage)<br><br>modified:   readme.txt<br></code></pre></td></tr></table></figure>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看。</li></ul><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><p>再学习回退之前，再练习更改一次</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">hi</span> this <span class="hljs-keyword">is</span> git study<br><span class="hljs-keyword">hi</span> I <span class="hljs-keyword">am</span> charon<br><span class="hljs-keyword">so</span> broing<br><br></code></pre></td></tr></table></figure><p>好了，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？<br>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>add broing</code>回退到上一个版本，就可以使用<code>git reset</code>命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git reset --hard HEAD^<br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-built_in">add</span> distributed<br><br>$ <span class="hljs-keyword">cat</span> readme.txt<br><span class="hljs-keyword">hi</span> this <span class="hljs-keyword">is</span> git study<br><span class="hljs-keyword">hi</span> I <span class="hljs-keyword">am</span> charon<br></code></pre></td></tr></table></figure><p>让我们用<code>git log</code>再看看现在版本库的状态:最新的版本不见了<br>但在Git中，总是有后悔药可以吃的。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令,在这里你可以找到之前版本的commit id 这样帮助你后悔<br><img src="/2023/02/07/Git%E7%AC%94%E8%AE%B0/14.jpg" alt="jizhong2"></p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>工作区（Working Directory）：就是你在电脑里能看到的目录（本地）<br>版本库（Repository）<br>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><img src="/2023/02/07/Git%E7%AC%94%E8%AE%B0/15.jpg" alt="Repository"><br>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ul><li>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改</li></ul><p>现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">hi</span> this <span class="hljs-keyword">is</span> git study<br><span class="hljs-keyword">hi</span> I <span class="hljs-keyword">am</span> charon<br>oooooooooooooooo~<br><br></code></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>.现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">update</span> what will <span class="hljs-keyword">be</span> committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> discard <span class="hljs-keyword">changes</span> in working directory)<br><br>modified:   readme.txt<br><br>Untracked <span class="hljs-keyword">files</span>:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-keyword">to</span> include in what will <span class="hljs-keyword">be</span> committed)<br><br>LICENSE<br><br><span class="hljs-keyword">no</span> <span class="hljs-keyword">changes</span> added <span class="hljs-keyword">to</span> commit (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>现在，暂存区的状态就变成这样了：<br><img src="/2023/02/07/Git%E7%AC%94%E8%AE%B0/18.jpg" alt="Repository4"><br>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git status<br><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：<br><img src="/2023/02/07/Git%E7%AC%94%E8%AE%B0/22.jpg" alt="Repository"></p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>因为<code>commit</code>只负责把暂存区的修改提交所以对于多次修改：<br>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>我现在在readme.txt文件里面增加一行内容，未提交到缓存区之前发现这行内容有错<br>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- readme.txt</span><br></code></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<br>注意：此方法对应的是工作区！</li></ul><p>现在假定你写了一堆bug还还<code>git add</code>到暂存区了，庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：<br>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset <span class="hljs-title class_">HEAD</span> readme.txt<br><span class="hljs-title class_">Unstaged</span> changes <span class="hljs-keyword">after</span> <span class="hljs-symbol">reset:</span><br>Mreadme.txt<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。<br>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。<br>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git add test.txt<br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&quot;add test.txt&quot;</span><br></code></pre></td></tr></table></figure><p>删除分为两步：</p><ul><li>用<code>rm</code>命令删了，然后<code>git status</code>命令会立刻告诉你哪些文件被删除了</li><li>那就用命令<code>git rm</code>删掉，并且<code>git commit</code><br>一般情况下，用<code>rm</code>命令删了，这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了所以需要进行第二步。<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure></li></ul><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- test.txt</span><br></code></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”<br>**注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。<br>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><h2 id="git-andGitHub"><a href="#git-andGitHub" class="headerlink" title="git andGitHub"></a>git andGitHub</h2><p>[[Git＆Github]]</p><p>本文学习于廖雪峰教程</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机基础知识</title>
    <link href="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.jpg" alt="jiegou"><br>在学习计算机结构时可以以一下为中心进行学习</p><ul><li>CPU</li><li>数据保存设备</li><li>周边设备</li><li>系统总线</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU主要由ALU(Arithmetic Logic Unit，算术/逻辑单元)CU(Control Unit，控制单元)寄存器组(Register Set)、总线接口(Bus Interface)组成。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.jpg" alt="CPU"></p><ol><li>ALU用于执行加减乘除、AND、OR、NOT等各种算术运算与逻辑运算。CU从输人寄存器获取数据，决定 ALU 执行运算的类型。此外，如何确定运算结果也由 CU 决定。  </li><li>CU 从存储器取出命令，并对命令进行解析，然后发送控制信号，控制各设备工作。CU 既可以通过组合逻辑单元由硬件实现，也可以通过编写程序使用软件实现。  </li><li>寄存器是CPU内部集成的高速小型保存器，一般用于保存当前计算中的值。大部分CPU会将数据从主存转移到寄存器，完成处理后再保存到内存。寄存器处于运算的中心位置。</li></ol><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>ٖ内存 (Memory)是计算机中最重要的部件之一，它是程序与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，其作用是存放CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.jpg" alt="neicun"><br>一般而言，计算机中使用的内存可以分为 ROM与RAM两种。</p><ul><li>ROM是一种非挥发性内存，用于保存有关计算机启动时的设备检查与从HDD加载引导程序(Bootstrap)的基本信息。  </li><li>RAM是计算机运行中使用的内存，进程使用的数据就保存于此。RAM是一种高速的挥发性保存设备只在电源接通时才能保存数据。<br>运行应用程序前，必须先将 HDD 中的数据加载到内存。由于内存容量有限，且同时供多个进程使用，所以会出现内存不足的问题。此时可以将 HDD的一部分空间用作虚拟内存，以弥补内存空间的不足，这种技术称为虚拟内存技术。<br>CPU内部含有高速寄存器。CPU执行运算前，需要先将命令与数据从内存读入寄存器，这<br>样能够大大提高访问速度。从CPU 角度看，访问内存并从指定地址读取数据要付出较高代价(时间)。因此，为了提升性能，CPU 内部或外部设置有高速缓存。系统会将常用数据放人高速缓存，以提升数据访问性能。SRAM是最常用的高速缓存。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.jpg" alt="xitong"><br>计算机运行过程中，操作系统处于最核心的地位。从软件层面看，操作系统管理进程的创建与销毁，支持进程同步与调度。还提供基于虚拟内存的内存管理技术，管理文件系统以使用计算机中的文件与目录。从硬件层面看，操作系统管理键盘、鼠标、显示器等多种周边设备的工作，也负责管理CPU。智能手机是一种在移动环境中使用的计算机，其操作系统管理相机、电子罗盘、GPS等多种传感器。<br>操作系统还提供错误检测与处理功能，以保证应用程序正常运行，确保其行为的一致性。比如，程序在正常运行过程中异常终止时，Windows操作系统就会弹出错误信息。此外，为了维护系统安全，操作系统还提供访问、管理资源以及安全认证等功能。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.jpg" alt="xitong2"></p><p>进程是指磁盘中的程序被装入内存并接受操作系统控制的状态。简言之，进程就是处于运行中的程序。磁盘中的程序要想运行，必须先转变为进程。进程占用一定内存，并通过CPU执行指定操作，有时也需要使用系统中的文件与I/O资源。操作系统提供的核心功能之一就是为进程分配与释放资源。资源分配与释放的效率是衡量操作系统性能与安全性的重要指标。<br>进程以PCB ( Process Control Block，进程控制块）形式表示，PCB随进程的创建而建立，伴随进程运行的整个过程，直到进程销毁而销毁。PCB是由操作系统管理的一种数据结构，包含进程ID、进程状态、程序计数、CPU寄存器、CPU调度信息、内存管理信息、账户信息、输人输出状态信息等。<br>进程占用CPU执行相应任务。运算所需数据从内存读入CPU内部的寄存器。分配给进程的CPU时间片耗尽时，进程就会进行上下文切换，将CPU资源让给其他进程使用。上下文切换过程中，寄存器中的数据会被保存到PCB，这样进程再次取得CPU的使用权时，就可以将这些数据恢复到寄存器继续运行。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>进程运行时，操作系统为其分配内存并进行管理。特别是在多进程环境中，操作系统必须保证各进程拥有独立的内存空间。从进程运行的观点看，内存管理可以分为</p><ol><li>虚拟内存管理功能</li><li>进程内存分配功能。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.jpg" alt="xitong3"><br>首先了解虚拟内存管理功能。如前所述，程序运行时需要先将数据装入内存。此时若物理内存不足，则操作系统会将一部分硬盘空间虚拟用作内存。虚拟内存技术下，大量数据会在主保存器（内存）与辅助保存器（硬盘）之间频繁交换。由于通过地址指定并管理各种数据会付出大量代价，所以操作系统以页面为单位进行管理，页面是使用固定大小的页帧在内存中划分的。<br>虚拟内存技术中，主保存器与辅助保存器虚拟绑定，看起来就像是在使用同一块内存一样。要做到“无中生有”，必须使用各种管理技术。</li><li>载入技术:决定何时从辅助保存器中将数据载入主保存器。</li><li>配置技术:决定将页面加载到主保存器的哪部分。</li><li>替换技术:主保存器中已经加载所有页面时，决定将哪些页面换出到辅助保存器。</li><li>分配技术:决定为进程分配的主保存器空间大小。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.jpg" alt="xitong4"><br>当程序运行，即从静态代码变为动态进程时，操作系统在虚拟内存区域中只为进程分配空间，用于保存进程运行所需的程序源代码，以及运行时出现的各种形式的数据。一般而言，分配给进程的内存分为代码区、数据区、BSS区、堆区域、栈区域这五部分，各区域具有不同功能。</li></ol><ul><li>代码区:该区域包含组成可执行文件的各种命令，保存着函数、控制语句、常数等，它们在进程创建时保存一次，直到进程销毁。代码区为只读区域，不可执行写入操作。</li><li>数据与BSS区域:这两个区域保存着全局变量、静态变量、数组、结构体等。在进程创建时分配空间，进程运行时存入值。这两个区域都是可读写的。</li><li>堆区域:该区域是事先预约的空间，供进程运行时使用。程序员调用API可以分配任意大小内存。一般调用malloc()或calloc()函数进行分配，调用free()函数进行释放。</li><li>栈区域:栈区域是程序自动使用的临时内存区域，用于保存局部变量的值，在函数调用时分配，函数退出时返还。堆与栈内存分配于相同空间。堆从低地址到高地址分配内存，栈从高地址向低地址分配内存，它们是系统黑客攻击的主要目标。在main()函数中，按照参数、返回地址、帧指针、局部变量序压入栈。</li><li><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2></li></ul><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.jpg" alt="yingyong1"></p><p>从编译器分类看，编程语言分为两种，一种是编译型语言，另一种是解释型语言。编译型语言经过编译器一次编译即可全部转换为目标代码。转换时，分析与优化同时进行，具有执行速度快的优点。解释型语言解析一行，代码即执行一行，执行速度相对较慢，但易于调试，可独立于操作系统进行开发。两种语言的共同点是，都需要将源代码转换为机器代码才能运行。Java语言同时具有上述两种特征，即编译时先将源代码转换为字节码，运行时再逐行解释执行。</p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.jpg" alt="yingyong2"></p><p>下面以编译型语言为例进行介绍。编译器用于将源代码转换为目标代码，此过程中并非只进行简单转换，还要对代码进行并行化处理，以便在多核环境中优化。此外还要分析代码，显示代码中的错误信息。一般而言，目标代码是汇编代码。汇编代码以人类易读的形式表示机器代码，它与机器代码是一一对应的。编译完成后，用户即可运行程序。用户双击可执行文件时，操作系统会将其加载到内存，并连接需要的DLL与库。如前所述，运行程序时，程序数据会被加载到代码、数据、BSS 区域，并分配运行所需的堆区域与栈区域。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络是一个复杂且庞大的知识框架，需进行阅读专业书籍认真学习！<br>计算机网络是指，通过通信线路连接多台计算机，实现资源共享与信息传递的计算机系统。计算机之间进行通信需要使用线缆、中继器、交换机、路由器等硬件设备，这些设备要正常工作则需要使用识别符、传输协议、路由等技术。</p><ol><li>识别符（ldentifier ):现实中，可以通过姓名或身份证号码识别区分每个人。与之类似，计算机也需要一种手段标识自己。最基本的是使用Mac地址，它是LAN卡分配的号码,是生产过程中由厂家烧入网卡的全球唯一编号。IP地址是识别每台计算机的逻辑单位。目前使用的IPv4协议中，IP地址由32位组成。进程是计算机内部的通信主体，它借助端口号识别。从通信观点看，端口技术实现了多个进程共享一个IP地址的目标。像这样，计算机通过MAC、IP、端口三种识别符相互识别并交换数据。</li><li>传输协议（Protocol ):计算机传送数据时，会将对方的地址、端口号、错误检查所需的各种信息一起发送。只有组成通信系统的交换机、路由器等设备知道所有信息后，才能将数据安全传送到目的地。首先，有必要制定关于传送数据的长度与哪种信息在哪个位置的详细规则。然后，设备制造商与程序开发人员必须根据这些规则生产与分析数据，这些规则就是通信协议。人们根据不同使用目的开发了多种协议，并一直在使用。</li><li>路由( Routing ):路由技术用于从数千万台计算机中找到自己想通信的计算机，并使找到的路径最快、最安全。路由由路由协议与路由器组成。目前有多种路由，请根据规模与预算选择使用。</li></ol><h3 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h3><table><thead><tr><th align="center">角度</th><th align="center">1.构成角度</th><th align="center">2.服务角度</th></tr></thead><tbody><tr><td align="center"></td><td align="center">设备：与网络相连的计算机常称为主机(host)=端系统end system,</td><td align="center">运行的网络应用程序分布式的应用进程，如：Web,email,电子商务,</td></tr><tr><td align="center"></td><td align="center">通信链路：光纤，同轴电缆，传输速率：带宽bps</td><td align="center">为分布式的应用进程提供通讯服务的基础设施（为app提供通讯服务）</td></tr><tr><td align="center"></td><td align="center">分组交换设备eg:路由器，交换机</td><td align="center">为app应用提供服务分为无连接不可靠服务，面向连接的可靠服务</td></tr></tbody></table><h3 id="互联网的三个阶段"><a href="#互联网的三个阶段" class="headerlink" title="互联网的三个阶段"></a>互联网的三个阶段</h3><blockquote><p>第一个阶段APPANET开发互联网，以TCP/IP协议族作为通讯规则</p><blockquote><p>第二阶段1985年NSF构成三级结构互联网</p><blockquote><p>第三阶段逐渐形成多层ISP结构互联网如，联通，电信也叫做internet服务提供商</p></blockquote></blockquote></blockquote><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>上一篇笔记</p><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>TCP/IP是世界范围内广泛使用的协议族。虽然它不像OSI七层模型那样是一种标准，但业界已经将其视为标准，被称为事实上(De facto）的通信协议。TCP/IP协议大致分为4层，类似于OSI七层模型，各层的功能划分也非常明确。TCP/IP协议各层功能与OSI七层模型大体一致，不再赘述。下面对具有代表性的几个协议进行讲解。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.jpg" alt="wangluo1"></p><ol><li>远程登录（ Telnet )<br>Telnet协议支持用户使用终端登录远程计算机，为用户提供了在本地计算机完成远程主机工作的能力。在使用网络方面，终端与仿真程序不同。由于传送的数据未经加密处理，为了保证数据安全，目前大量使用SSH协议。</li><li>FTP ( File Transfer Protocol )<br>FTP用于通过网络传送大体积文件，其使用简单、数据传输速度快，故而得到广泛应用。但由于传送的数据，尤其认证时使用的ID与密码都是明文形式，所以存在诸多安全隐患。需要确保传输安全时，应当使用SFTP ( Secure FTP)协议。</li><li>TCP ( Transmission Control Protocol )<br>TCP传输控制协议为网络中的计算机提供了安全、有序、无差错的数据传输服务。TCP是面向连接的协议，它保证交换数据的两台计算机在逻辑上总是连接状态。由于TCP总是与IP成对使用，所以将其统称为TCP/IP，代表TCP协议与IP协议的组合。为了解决三次握手过程中发生的性能低下与安全问题，人们开发了SCTP ( Stream Control TransmissionProtocol)协议。可靠</li><li>UDP ( User Datagram Protocol )<br>与TCP协议类似，UDP协议也用于在计算机之间传送数据。不同的是，它并不保证通信双方之间总存在逻辑连接。一般而言，发送方只负责发送数据，并不支持顺序控制、错误控制等安全机制。UDP协议使用简单，且支持快速传输数据。在稳定的网络环境中，使用UDP比 TCP更有利。不可靠</li><li>IP ( lnternet Protocol )<br>IP协议以IPv4地址系统为基础，将数据包通过网络传送至目的地。IPv4支持32位网络地址。由于目前对IP地址提出需求的设备呈现几何增长，相信基于64位地址的IPv6很快就会取代IPv4。出于安全考虑，IPv6本身就支持IPSec，大大提高了网络通信的安全性。 </li><li>ARP (Address Resolution Protocol )<br>ARP协议从逻辑地址（IP）获取相应物理地址（MAC)，在计算机交换数据包时，需要知道通信双方的物理地址。通常，我们熟知的基于32位的IP地址 （ ex:210.53.26.123）是供人类而非计算机识别的逻辑地址。计算机识别物理地址，即 MAC地址（ ex: 00-1D-7D-9A-BB-62)。ARP协议用于将逻辑地址（IP)变换为物理地址（MAC)。而RARP ( ReverseARP)协议则用于根据物理地址获取相应的逻辑地址。</li><li>ICMP ( Internet Control Message Protocol )<br>IP协议缺少错误控制功能，为了弥补这一不足，人们设计了ICMP协议。借助ICMP协议，路由器可以传送IP包处理过程中发生的错误信息，网络管理员也可以用其向路由器或其他计算机请求获取特定信息。</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.jpg" alt="wangluo2"><br>DNS将人们易于理解的域名变换为网络中使用的识别符（IP)。与IP类似，域名也由国际机构统一管理，各国都有域名注册代理机构。同一域名可以映射多个IP地址。分配给服务设备的IP地址发生改动时，只要更改DNS中的IP地址，即可一次性应用于全球所有系统。使用域名不仅能加深人们对服务的理解，也能大大方便人们连接并使用互联网。<br>比如，在浏览器地址栏输人网址 后，程序首先会在系统的hosts文件中搜索已有的域名与IP地址。假设查找到记录为140.100.90.9 则浏览器会将140.100.90.9识别为IP地址，并进行连接请求Web服务。hosts文件通常只用于测试，浏览器一般会在第一层DNS 中查找域名对应的IP地址。一个全新的域名可能不存在于第一层DNS，此时第一层DNS 会向第二层DNS发送目录更新请求，更新自身数据库后，将相关IP地址发送给用户PC</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.jpg" alt="wangluo3"><br>可以将网络简单理解为数千万台计算机通过数十万台路由器连接的系统。路由用于确定数据经由哪些路由器可以最快速度到达目的地。各台路由器通过与邻近路由器交换信息维护最佳路径信息。路由协议用于在路由器之间共享路由信息，确保所有路由器知道通往其他路由器的路径。<br>用户PC 访问 Web服务时，首先要通过DNS服务器查找Web服务器的IP地址，然后决定走哪条路到达目的地。出发地是用户PC连接的本地路由器。本地路由器查找自身路由表，搞清目的路由器所在位置。若在自身路由表中查找不到与目的路由器有关的信息，则向邻近路由器询问。如此反复，最终找到一条到达目的地的最优路径，然后发送数据包。</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.jpg" alt="web1"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>浏览器向Web服务器请求服务时，会根据HTTP请求协议发送数据。HTTP请求协议由协议头与协议体组成，协议头含有方法类型、请求URL等服务处理所需的各种信息，而协议体则包含表单参数,与用户输入值对应。</p><h3 id="Cookie与会话"><a href="#Cookie与会话" class="headerlink" title="Cookie与会话"></a>Cookie与会话</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/35.jpg" alt="web1"></p><p>Web技术提供了向浏览器保存数据的空间，称为Cookie。Web发展早期、用户认证信息大都保存在Cookie中，但由于存在安全隐患，目前人们只将简单的控制信息、会话ID信息保存于此。由于Cookie信息包含于HTTP协议头信息，所以可以将其用作在客户端与服务器之间传递信息的手段。会话是保存用户信息的Web服务器对象。一般而言，用户登录后，用户信息就会保存在会话之中，然后通过Cookie将会话ID(用于标识会话的识别符）传递给浏览器。用户通过浏览器访问购物车时，Web服务器会使用通过HTTP头传递的会话ID(位于Cookie)判断是否是认证用户。下面简单讲解基于会话的认证系统。<br>①创建会话:创建用于保存用户认证信息的会话。创建的会话由Web服务器管理，保存在 Web服<br>务器进程占用的内存中。<br>②传送会话ID:创建会话时，会同时创建用于标识会话的ID。为了判断相应客户端是否已经认证.<br>在 HTTP响应的 Set-Cookie字段一同传送会话ID。<br>③保存会话ID:浏览器从HTTP响应头提取会话ID并添加到Cookie。<br>④传送会话ID:请求服务时，浏览器会将所有Cookie 值放入HTTP请求头的Cookie字段，并进行<br>传送。当然，这其中也包含会话ID。<br>⑤识别会话:Web服务器分析HTTP头，从中提取会话ID。然后根据相应ID从自身会话列表提取<br>相应值,进行认证。</p><p>本文整理参考《python黑客攻防入门》一书</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI模型</title>
    <link href="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><h3 id="分层模型及原理"><a href="#分层模型及原理" class="headerlink" title="分层模型及原理"></a>分层模型及原理</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B/3187025?fromModule=lemma_inlink">概念模型</a>，由<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832?fromModule=lemma_inlink">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/6.png" alt="gainian"></p><h4 id="2-分层原理："><a href="#2-分层原理：" class="headerlink" title="2.分层原理："></a>2.分层原理：</h4><ul><li>根据不同层次，抽象分层</li><li>每层实现一个定义明确的功能</li><li>功能的选择有助于制定协议的国际标准</li><li>层数应足够多，但也不能太多</li></ul><p><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/0.jpg" alt="fenceng"></p><h4 id="3-简要功能"><a href="#3-简要功能" class="headerlink" title="3.简要功能"></a>3.简要功能</h4><table><thead><tr><th>层</th><th>简要功能</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务并规定通信细节</td></tr><tr><td>表示层</td><td>主要是数据格式的转换</td></tr><tr><td>会话层</td><td>建立和断开通信连接</td></tr><tr><td>传输层</td><td>负责寻找地址/路由选择</td></tr><tr><td>网络层</td><td>通讯双方节点的可靠传输</td></tr><tr><td>数据链路层</td><td>物理层之上的互联节点之间的通信，数据帧的生成接收</td></tr><tr><td>物理层</td><td>以0，1形式在物理媒体上传输数据</td></tr></tbody></table><p><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/3.webp" alt="gongneng"></p><p>百度的比喻很好</p><p>OSI将<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%25E4%25BD%2593%25E7%25B3%25BB%25E7%25BB%2593%25E6%259E%2584?fromModule=lemma_inlink">计算机网络体系结构</a>(architecture）划分为以下七层：</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E7%2589%25A9%25E7%2590%2586%25E5%25B1%2582?fromModule=lemma_inlink">物理层</a>: 将数据转换为可通过物理介质传送的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E7%2594%25B5%25E5%25AD%2590%25E4%25BF%25A1%25E5%258F%25B7?fromModule=lemma_inlink">电子信号</a> 相当于邮局中的搬运工人。</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582?fromModule=lemma_inlink">数据链路层</a>: 决定访问网络介质的方式。</p><p>在此层将数据分帧，并处理流控制。本层指定<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E6%258B%2593%25E6%2589%2591%25E7%25BB%2593%25E6%259E%2584?fromModule=lemma_inlink">拓扑结构</a>并提供硬件寻址，相当于邮局中的装拆箱工人。</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E7%25BD%2591%25E7%25BB%259C%25E5%25B1%2582/4329439?fromModule=lemma_inlink">网络层</a>: 使用权数据路由经过大型网络 相当于邮局中的排序工人。</p><p>传输层: 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员。</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E4%25BC%259A%25E8%25AF%259D%25E5%25B1%2582?fromModule=lemma_inlink">会话层</a>: 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书。</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E8%25A1%25A8%25E7%25A4%25BA%25E5%25B1%2582?fromModule=lemma_inlink">表示层</a>: 协商数据交换格式 相当公司中简报老板、替老板写信的助理。</p><p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E5%25BA%2594%25E7%2594%25A8%25E5%25B1%2582/4329788?fromModule=lemma_inlink">应用层</a>: 用户的应用程序和网络之间的接口。</p><h4 id="4-物理层"><a href="#4-物理层" class="headerlink" title="4.物理层"></a>4.物理层</h4><p>1.简介:物理层作为第一层，其数据单位为比特，由计算机和网络介质之间的实际界面组成。负责0，1比特流（0，1序列）与电压高低，光的闪灭之间的转换，0代表低电平，1代表高电平，在设计时必须保证发送与接受一致。</p><p>2.这层主要涉及机械，电气，功能等特征</p><p>3.主要设备:中继器，集线器等</p><h4 id="5-数据链路层"><a href="#5-数据链路层" class="headerlink" title="5.数据链路层"></a>5.数据链路层</h4><p>1.简介：其主要功能是物理层之上的互联节点之间的通信，数据帧的生成接收，但主要工作是将一个原始的传输设施转变成一条逻辑的传输线路，其基本单位为帧。为了完成任务让发送方将输入的数据拆开，分装到数据顿中，然后有序地传送这些数据帧，数据链路层的服务是可靠的，接收方需要确认每一个帧都已经正确地接收到了，即给发送方返回一个确认帧。</p><p>2.主要协议：SDLC、HDLC、PPP、STP、帧中继</p><h4 id="6-网络层"><a href="#6-网络层" class="headerlink" title="6.网络层"></a>6.网络层</h4><p>1.简介：其主要功能是通讯双方节点的可靠传输，或者可以理解为控制子网的运行过程。（子网：对于一般由<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E8%25B7%25AF%25E7%2594%25B1%25E5%2599%25A8/108294?fromModule=lemma_inlink">路由器</a>和<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%25E4%25B8%25BB%25E6%259C%25BA/455151?fromModule=lemma_inlink">主机</a>组成的互连系统），为完成工作网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组，但是如果有太多的分组同时出现在一个子网中，那么这些分组彼此之间会相互妨碍，从而形成传输瓶颈。所以拥塞控制也属于网络层的范畴</p><p>2.主要协议：IP、IPX、RIP、OSPF</p><h4 id="7-传输层"><a href="#7-传输层" class="headerlink" title="7.传输层"></a>7.传输层</h4><p>1.简介：基本功能是接收来自上一层的数据，并且在必要的时候把这些数据分割成小的单元，然后把数据单元传递给网络层，还决定向会话层提供何种类型的服务。传输层是一个真正的端到端的层，所有的处理都是按照从源端到目标端来进行的。</p><p>2.主要协议：TCP、UDP、SPX</p><h4 id="8-会话层"><a href="#8-会话层" class="headerlink" title="8.会话层"></a>8.会话层</h4><p>1.简介：基本功能是负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接，说简单点就是通讯双方节点的可靠传输。会话层的服务包括对话控制、令牌管理及同步功能。对话控制是指会话层允许信息同时双向传输，或者任意一个时刻只能单向传输。令牌管理是指禁止双方同时执行同一个关键操作。同步功能是指在一个长的传输过程中设置一些检查点，以便在系统崩溃后还能够在崩溃前的一点上继续执行。</p><h4 id="9-表示层"><a href="#9-表示层" class="headerlink" title="9.表示层"></a>9.表示层</h4><p>1.简介：基本功能是把数据转换为能与接收者的系统格式兼容并适合传输的格式。表示层关心的是所传递的信息的语法和语义。同时，表示层还定义了一种标准的编码方法用来表达网络线路上所传递的数据，来达到传输数据的目的。同时，加密，压缩也在这层次上进行。</p><h4 id="10-应用层"><a href="#10-应用层" class="headerlink" title="10.应用层"></a>10.应用层</h4><p>1.简介：提供为应用软件而设的接口，以设置与另一应用软件之间的通信，应用层包含了各种各样的协议规定应用软件如何进行通信，这些协议往往直接针对用户的需要。应用层的另外一个功能是文件传输。总结一下就是为网络应用提供服务，执行用户活动的一个层次</p><p>2.主要协议：Telnet、FTP、HTTP、SNMP</p><h4 id="11-通信"><a href="#11-通信" class="headerlink" title="11.通信"></a>11.通信</h4><p>为了便于理解关于OSI模型的通信，这里举的是图解TCP/IP中并不是很严谨的例子<br><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/9.jpg" alt="tongxin"><br> 发 送 方 从 第 7 层 、第 6 层 到 第 1 层 由 上 至 下 按 照 顺 序 传 输 数 据 ， 而 接 收 端 则 从 第 1 层 、 第 2 层 到 第 7层 由 下 至 上 向 每 个 上 一 级 分 层 传 输 数 据 。 每 个 分 层 上 ， 在 处 理 由 上 一 层 传 过 来 的数 据 时 可 以 附 上 当 前 分 层 的 协 议 所 必 须 的 “ 首 部 “ 信 息 。 然 后 接 收 端 对 收 到 的 数据 进 行 数 据 “ 首 部 ” 与 “ 内 容 ” 的 分 离 ， 再 转 发 给 上 一 分 层 ， 并 最 终 将 发 送 端 的数 据 恢 复 为 原 状 。</p><h4 id="12-最后图解"><a href="#12-最后图解" class="headerlink" title="12.最后图解"></a>12.最后图解</h4><p><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/5.jpg" alt="tujie"><br><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/8.png" alt="tujie2"><br><img src="/2023/02/05/OSI%E6%A8%A1%E5%9E%8B/7.jpg" alt="tujie3"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/02/hello-world/"/>
    <url>/2023/02/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
